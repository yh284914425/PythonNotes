# 04-打包基础

## 📦 Python打包概述

### 什么是Python打包？
Python打包是将你的代码、依赖和元数据组织成可分发格式的过程，使其他人能够轻松安装和使用你的代码。

### 打包的目的
```python
packaging_purposes = {
    "代码分发": "让其他人能够安装和使用你的代码",
    "依赖管理": "自动处理项目的依赖关系",
    "版本控制": "管理不同版本的发布",
    "跨平台": "在不同操作系统上运行",
    "标准化": "遵循Python社区标准",
    "自动化": "简化安装和部署过程"
}
```

### Python包的类型
```python
package_types = {
    "源码包": {
        "格式": ".tar.gz",
        "特点": "包含源代码，需要编译",
        "适用": "纯Python包或需要编译的包"
    },
    "二进制包": {
        "格式": ".whl (wheel)",
        "特点": "预编译，安装快速",
        "适用": "包含C扩展或预编译的包"
    },
    "开发包": {
        "格式": "可编辑安装",
        "特点": "直接链接到源码目录",
        "适用": "开发阶段使用"
    }
}
```

## 🏗️ 包的基本结构

### 最小包结构
```
my_package/
├── setup.py              # 安装脚本（传统）
├── pyproject.toml        # 项目配置（现代）
├── README.md             # 项目说明
├── LICENSE              # 许可证
└── my_package/          # 包源码
    ├── __init__.py      # 包初始化
    └── module.py        # 模块代码
```

### 完整包结构
```
my_project/
├── pyproject.toml       # 项目配置
├── setup.py            # 安装脚本（可选）
├── setup.cfg           # 配置文件（可选）
├── README.md           # 项目说明
├── LICENSE             # 许可证
├── CHANGELOG.md        # 更新日志
├── MANIFEST.in         # 包含文件清单
├── requirements.txt    # 依赖列表
├── src/                # 源码目录（推荐）
│   └── my_package/
│       ├── __init__.py
│       ├── core.py
│       └── utils.py
├── tests/              # 测试代码
│   ├── __init__.py
│   ├── test_core.py
│   └── test_utils.py
├── docs/               # 文档
│   ├── index.md
│   └── api.md
└── examples/           # 示例代码
    └── basic_usage.py
```

## 📄 包的元数据

### 基本元数据
```python
# 包的基本信息
package_metadata = {
    "name": "my-awesome-package",      # 包名（PyPI上唯一）
    "version": "1.0.0",               # 版本号
    "description": "简短描述",         # 一句话描述
    "long_description": "详细描述",    # 详细描述（通常来自README）
    "author": "作者姓名",              # 作者
    "author_email": "email@example.com", # 作者邮箱
    "url": "https://github.com/user/repo", # 项目主页
    "license": "MIT",                 # 许可证
    "python_requires": ">=3.8",      # Python版本要求
}
```

### 分类信息
```python
# PyPI分类器
classifiers = [
    # 开发状态
    "Development Status :: 4 - Beta",
    
    # 目标受众
    "Intended Audience :: Developers",
    "Intended Audience :: Science/Research",
    
    # 许可证
    "License :: OSI Approved :: MIT License",
    
    # 编程语言
    "Programming Language :: Python :: 3",
    "Programming Language :: Python :: 3.8",
    "Programming Language :: Python :: 3.9",
    "Programming Language :: Python :: 3.10",
    "Programming Language :: Python :: 3.11",
    
    # 操作系统
    "Operating System :: OS Independent",
    
    # 主题
    "Topic :: Software Development :: Libraries :: Python Modules",
    "Topic :: Scientific/Engineering",
]
```

### 依赖管理
```python
# 依赖类型
dependencies = {
    "install_requires": [
        "requests>=2.25.0",      # 运行时依赖
        "click>=7.0",
        "pydantic>=1.8.0",
    ],
    "extras_require": {
        "dev": [                 # 开发依赖
            "pytest>=6.0",
            "black>=22.0",
            "flake8>=4.0",
        ],
        "docs": [                # 文档依赖
            "sphinx>=4.0",
            "sphinx-rtd-theme",
        ],
        "test": [                # 测试依赖
            "pytest>=6.0",
            "pytest-cov>=3.0",
        ],
    },
    "python_requires": ">=3.8", # Python版本要求
}
```

## 🔧 构建工具

### setuptools（传统工具）
```python
# setup.py 示例
from setuptools import setup, find_packages

with open("README.md", "r", encoding="utf-8") as fh:
    long_description = fh.read()

setup(
    name="my-package",
    version="1.0.0",
    author="Your Name",
    author_email="your.email@example.com",
    description="A short description",
    long_description=long_description,
    long_description_content_type="text/markdown",
    url="https://github.com/yourusername/my-package",
    packages=find_packages(),
    classifiers=[
        "Programming Language :: Python :: 3",
        "License :: OSI Approved :: MIT License",
        "Operating System :: OS Independent",
    ],
    python_requires=">=3.8",
    install_requires=[
        "requests>=2.25.0",
    ],
    extras_require={
        "dev": ["pytest>=6.0", "black", "flake8"],
    },
    entry_points={
        "console_scripts": [
            "my-tool=my_package.cli:main",
        ],
    },
)
```

### build（现代构建工具）
```bash
# 安装build工具
pip install build

# 构建包
python -m build

# 只构建wheel
python -m build --wheel

# 只构建源码包
python -m build --sdist

# 指定输出目录
python -m build --outdir dist/
```

### wheel格式
```python
# wheel的优势
wheel_advantages = {
    "安装快速": "预编译，无需构建步骤",
    "跨平台": "支持不同平台的二进制包",
    "缓存友好": "pip可以缓存wheel文件",
    "标准格式": "Python官方推荐的分发格式",
    "元数据丰富": "包含完整的包元数据"
}

# wheel文件命名
# {package}-{version}(-{build tag})?-{python tag}-{abi tag}-{platform tag}.whl
wheel_naming = {
    "package": "包名",
    "version": "版本号",
    "build_tag": "构建标签（可选）",
    "python_tag": "Python版本标签",
    "abi_tag": "ABI标签",
    "platform_tag": "平台标签"
}

# 示例：requests-2.28.1-py3-none-any.whl
```

## 📋 MANIFEST.in文件

### MANIFEST.in的作用
MANIFEST.in文件指定哪些文件应该包含在源码分发包中。

### MANIFEST.in语法
```
# MANIFEST.in 示例

# 包含文件
include README.md
include LICENSE
include CHANGELOG.md
include requirements.txt

# 包含目录下的所有文件
recursive-include docs *.md *.rst
recursive-include examples *.py

# 包含特定模式的文件
include my_package/data/*.json
include my_package/templates/*.html

# 排除文件
exclude .gitignore
exclude .env

# 排除目录
prune tests/
prune .git/

# 全局排除模式
global-exclude *.pyc
global-exclude __pycache__
global-exclude .DS_Store
```

### 常用MANIFEST.in模板
```
# 基本文件
include README.md
include LICENSE
include CHANGELOG.md
include pyproject.toml
include setup.py
include setup.cfg

# 需求文件
include requirements*.txt

# 数据文件
recursive-include my_package/data *
recursive-include my_package/templates *
recursive-include my_package/static *

# 文档
recursive-include docs *.md *.rst *.txt

# 示例
recursive-include examples *.py

# 排除开发文件
exclude .gitignore
exclude .pre-commit-config.yaml
exclude tox.ini
exclude Makefile

# 排除测试和构建文件
prune tests/
prune .git/
prune .github/
prune build/
prune dist/
prune *.egg-info/

# 排除缓存文件
global-exclude *.pyc
global-exclude __pycache__
global-exclude .DS_Store
global-exclude *.so
```

## 🎯 版本管理

### 语义化版本控制
```python
# SemVer格式：MAJOR.MINOR.PATCH
semantic_versioning = {
    "MAJOR": "不兼容的API修改",
    "MINOR": "向后兼容的功能性新增", 
    "PATCH": "向后兼容的问题修正"
}

# 版本示例
version_examples = {
    "1.0.0": "首个稳定版本",
    "1.1.0": "新增功能，向后兼容",
    "1.1.1": "修复bug，向后兼容",
    "2.0.0": "重大更新，可能不兼容",
    "2.0.0-alpha.1": "预发布版本",
    "2.0.0-beta.1": "测试版本",
    "2.0.0-rc.1": "发布候选版本"
}
```

### 动态版本管理
```python
# 使用setuptools_scm从Git标签获取版本
# pyproject.toml
"""
[build-system]
requires = ["setuptools>=45", "setuptools_scm[toml]>=6.2"]

[tool.setuptools_scm]
write_to = "my_package/_version.py"
"""

# 在代码中使用版本
# my_package/__init__.py
try:
    from ._version import version as __version__
except ImportError:
    __version__ = "unknown"
```

## 🔍 包验证

### 检查包结构
```bash
# 使用check-manifest检查MANIFEST.in
pip install check-manifest
check-manifest

# 使用twine检查包
pip install twine
twine check dist/*

# 使用setup.py检查
python setup.py check --strict --metadata
```

### 测试安装
```bash
# 本地安装测试
pip install -e .

# 从构建的包安装
pip install dist/my_package-1.0.0-py3-none-any.whl

# 在新环境中测试
python -m venv test_env
source test_env/bin/activate
pip install dist/my_package-1.0.0.tar.gz
python -c "import my_package; print(my_package.__version__)"
```

## 🎯 本节小结

- **打包概念**：理解Python打包的目的和重要性
- **包结构**：掌握标准的包目录结构
- **元数据管理**：正确设置包的元数据信息
- **构建工具**：使用现代工具构建包
- **版本管理**：采用语义化版本控制

## 💡 关键要点

1. **结构规范**：遵循Python包的标准结构
2. **元数据完整**：提供完整准确的包元数据
3. **依赖明确**：清晰声明包的依赖关系
4. **版本语义**：使用语义化版本控制
5. **测试验证**：构建后进行充分测试

## 📚 延伸阅读
- [Python打包用户指南](https://packaging.python.org/)
- [setuptools文档](https://setuptools.pypa.io/)
- [wheel格式规范](https://peps.python.org/pep-0427/)
- [语义化版本控制](https://semver.org/)
