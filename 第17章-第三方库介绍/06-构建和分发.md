# 06-构建和分发

## 🏗️ 构建过程概述

### 什么是构建？
构建是将源代码转换为可分发格式的过程，包括：
- **源码包构建**：创建包含源代码的.tar.gz文件
- **二进制包构建**：创建预编译的.whl文件
- **依赖解析**：确定和验证依赖关系
- **元数据生成**：创建包的元数据信息

### 构建产物类型
```python
build_artifacts = {
    "源码分发包": {
        "格式": ".tar.gz (sdist)",
        "内容": "源代码 + 元数据",
        "特点": "需要在安装时编译",
        "适用": "纯Python包或需要编译的包"
    },
    "二进制分发包": {
        "格式": ".whl (wheel)",
        "内容": "预编译代码 + 元数据",
        "特点": "安装快速，无需编译",
        "适用": "所有包，特别是包含C扩展的包"
    }
}
```

## 🔨 现代构建工具

### build - 官方推荐工具
```bash
# 安装build工具
pip install build

# 构建所有格式
python -m build

# 只构建wheel
python -m build --wheel

# 只构建源码包
python -m build --sdist

# 指定输出目录
python -m build --outdir custom_dist/

# 详细输出
python -m build --verbose
```

### build工具的优势
```python
build_advantages = {
    "标准化": "遵循PEP 517/518标准",
    "隔离构建": "在隔离环境中构建，避免污染",
    "后端无关": "支持不同的构建后端",
    "简单易用": "命令简单，配置最少",
    "官方推荐": "Python官方推荐的构建工具"
}
```

### 构建配置
```toml
# pyproject.toml中的构建配置
[build-system]
requires = [
    "setuptools>=61.0",
    "wheel",
    "setuptools_scm[toml]>=6.2"
]
build-backend = "setuptools.build_meta"

# 使用不同的构建后端
[build-system]
requires = ["flit_core >=3.2,<4"]
build-backend = "flit_core.buildapi"

# 或者使用poetry
[build-system]
requires = ["poetry-core"]
build-backend = "poetry.core.masonry.api"
```

## 📦 setuptools构建

### 传统构建方式
```bash
# 使用setup.py构建（不推荐）
python setup.py sdist bdist_wheel

# 清理构建文件
python setup.py clean --all

# 检查包
python setup.py check --strict --metadata
```

### setuptools配置
```toml
# pyproject.toml中的setuptools配置
[tool.setuptools]
package-dir = {"" = "src"}
include-package-data = true

[tool.setuptools.packages.find]
where = ["src"]
include = ["my_package*"]
exclude = ["my_package.tests*"]

[tool.setuptools.package-data]
my_package = [
    "data/*.json",
    "templates/*.html",
    "static/css/*.css",
    "static/js/*.js"
]

[tool.setuptools.exclude-package-data]
"*" = ["*.pyc", "__pycache__", "*.so"]
```

### 动态配置
```python
# 动态版本获取
# my_package/__init__.py
__version__ = "1.0.0"

# pyproject.toml
[tool.setuptools.dynamic]
version = {attr = "my_package.__version__"}
readme = {file = ["README.md"], content-type = "text/markdown"}
```

## 🎯 构建最佳实践

### 项目结构建议
```
my_project/
├── pyproject.toml          # 项目配置
├── README.md              # 项目说明
├── LICENSE               # 许可证
├── CHANGELOG.md          # 更新日志
├── MANIFEST.in           # 包含文件清单
├── src/                  # 源码目录（推荐）
│   └── my_package/
│       ├── __init__.py
│       ├── core.py
│       └── data/
│           └── config.json
├── tests/                # 测试目录
│   ├── __init__.py
│   └── test_core.py
├── docs/                 # 文档目录
└── scripts/              # 脚本目录
```

### MANIFEST.in最佳实践
```
# MANIFEST.in - 控制源码包内容

# 包含重要文件
include README.md
include LICENSE
include CHANGELOG.md
include pyproject.toml

# 包含数据文件
recursive-include src/my_package/data *.json *.yaml *.txt
recursive-include src/my_package/templates *.html *.jinja2

# 包含文档
recursive-include docs *.md *.rst *.txt

# 排除不需要的文件
exclude .gitignore
exclude .pre-commit-config.yaml
exclude tox.ini
exclude Makefile

# 排除目录
prune .git
prune .github
prune .pytest_cache
prune build
prune dist
prune *.egg-info

# 全局排除
global-exclude *.pyc
global-exclude __pycache__
global-exclude .DS_Store
global-exclude *.so
global-exclude *.pyd
```

### 构建前检查
```bash
# 检查包结构
check-manifest

# 检查元数据
python -m build --sdist
twine check dist/*

# 验证wheel内容
python -m zipfile -l dist/my_package-1.0.0-py3-none-any.whl

# 测试安装
pip install dist/my_package-1.0.0-py3-none-any.whl
```

## 🚀 分发准备

### 版本管理
```python
# 语义化版本控制
version_strategy = {
    "开发版本": "1.0.0.dev0",
    "预发布版本": "1.0.0a1, 1.0.0b1, 1.0.0rc1",
    "正式版本": "1.0.0",
    "修补版本": "1.0.1",
    "功能版本": "1.1.0",
    "重大版本": "2.0.0"
}

# 使用setuptools_scm自动版本
# pyproject.toml
[tool.setuptools_scm]
write_to = "src/my_package/_version.py"
version_scheme = "post-release"
local_scheme = "dirty-tag"
```

### 依赖管理
```toml
# 合理的依赖约束
[project]
dependencies = [
    "requests>=2.25.0,<3.0.0",  # 兼容范围
    "click>=7.0",               # 最小版本
    "pydantic>=1.8.0,<2.0.0",  # 主版本约束
]

# 可选依赖
[project.optional-dependencies]
dev = [
    "pytest>=6.0",
    "black>=22.0",
    "flake8>=4.0",
    "mypy>=0.950",
]
docs = [
    "sphinx>=4.0",
    "sphinx-rtd-theme>=1.0",
]
all = [
    "my-package[dev,docs]",
]
```

### 元数据完善
```toml
[project]
name = "my-awesome-package"
version = "1.0.0"
description = "A comprehensive Python package for awesome things"
readme = "README.md"
license = {file = "LICENSE"}
authors = [
    {name = "Your Name", email = "your.email@example.com"},
]
maintainers = [
    {name = "Team Lead", email = "lead@example.com"},
]
keywords = ["awesome", "python", "package"]
classifiers = [
    "Development Status :: 5 - Production/Stable",
    "Intended Audience :: Developers",
    "License :: OSI Approved :: MIT License",
    "Programming Language :: Python :: 3",
    "Programming Language :: Python :: 3.8",
    "Programming Language :: Python :: 3.9",
    "Programming Language :: Python :: 3.10",
    "Programming Language :: Python :: 3.11",
    "Topic :: Software Development :: Libraries :: Python Modules",
]
requires-python = ">=3.8"

[project.urls]
Homepage = "https://github.com/yourusername/my-awesome-package"
Documentation = "https://my-awesome-package.readthedocs.io/"
Repository = "https://github.com/yourusername/my-awesome-package.git"
"Bug Tracker" = "https://github.com/yourusername/my-awesome-package/issues"
Changelog = "https://github.com/yourusername/my-awesome-package/blob/main/CHANGELOG.md"
```

## 🔍 质量检查

### 自动化检查脚本
```bash
#!/bin/bash
# build_check.sh - 构建前质量检查

set -e

echo "🔍 检查代码格式..."
black --check src/ tests/

echo "🔍 检查导入排序..."
isort --check-only src/ tests/

echo "🔍 检查代码质量..."
flake8 src/ tests/

echo "🔍 类型检查..."
mypy src/

echo "🔍 运行测试..."
pytest tests/ --cov=src/

echo "🔍 检查包清单..."
check-manifest

echo "🔍 构建包..."
python -m build

echo "🔍 检查构建产物..."
twine check dist/*

echo "✅ 所有检查通过！"
```

### 测试安装
```bash
# 创建测试环境
python -m venv test_install
source test_install/bin/activate

# 从wheel安装
pip install dist/my_package-1.0.0-py3-none-any.whl

# 测试导入
python -c "import my_package; print(my_package.__version__)"

# 测试命令行工具
my-tool --help

# 清理
deactivate
rm -rf test_install
```

## 📊 构建优化

### 构建性能优化
```python
optimization_tips = {
    "并行构建": "使用多核CPU加速编译",
    "缓存利用": "利用构建缓存减少重复工作",
    "依赖预编译": "使用预编译的依赖包",
    "增量构建": "只构建变更的部分",
    "构建环境": "使用专门的构建环境"
}
```

### wheel标签优化
```python
# wheel文件命名解析
# package-version-python_tag-abi_tag-platform_tag.whl

wheel_tags = {
    "python_tag": {
        "py3": "Python 3.x通用",
        "py38": "Python 3.8专用",
        "cp38": "CPython 3.8专用"
    },
    "abi_tag": {
        "none": "纯Python，无ABI依赖",
        "cp38m": "CPython 3.8 with pymalloc",
        "abi3": "稳定ABI"
    },
    "platform_tag": {
        "any": "平台无关",
        "win_amd64": "Windows 64位",
        "macosx_10_9_x86_64": "macOS x86_64",
        "linux_x86_64": "Linux x86_64"
    }
}
```

## 🎯 本节小结

- **现代构建**：使用build工具进行标准化构建
- **构建配置**：在pyproject.toml中配置构建参数
- **质量检查**：构建前进行全面的质量检查
- **分发准备**：完善元数据和依赖管理
- **优化策略**：提高构建效率和包质量

## 💡 关键要点

1. **工具选择**：使用现代构建工具如build
2. **标准遵循**：遵循PEP 517/518构建标准
3. **质量保证**：构建前进行全面检查
4. **元数据完整**：提供完整准确的包信息
5. **测试验证**：构建后测试安装和功能

## 📚 延伸阅读
- [PEP 517 - 构建系统接口](https://peps.python.org/pep-0517/)
- [PEP 518 - 构建系统要求](https://peps.python.org/pep-0518/)
- [build工具文档](https://build.pypa.io/)
- [wheel格式规范](https://peps.python.org/pep-0427/)

---
**下一节预告**：07-发布到PyPI - 学习如何将包发布到Python包索引
