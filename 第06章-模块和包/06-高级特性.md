# 06-高级特性

## 🔧 模块的高级属性和内省

### 1. 模块属性详解
```python
import math
import sys

# 基本模块属性
print(f"模块名: {math.__name__}")           # 'math'
print(f"模块文档: {math.__doc__[:50]}...")   # 模块文档字符串
print(f"模块文件: {getattr(math, '__file__', '内置模块')}")

# 查看模块的所有属性
attributes = dir(math)
print(f"math模块属性数量: {len(attributes)}")
print(f"部分属性: {attributes[:10]}")

# 检查属性类型
for attr_name in ['pi', 'sqrt', 'sin']:
    attr = getattr(math, attr_name)
    print(f"{attr_name}: {type(attr).__name__}")
```

### 2. 动态属性访问
```python
# 动态获取属性
module_name = 'math'
attr_name = 'pi'

# 方法1: getattr
module = __import__(module_name)
value = getattr(module, attr_name)
print(f"{module_name}.{attr_name} = {value}")

# 方法2: hasattr检查
if hasattr(module, attr_name):
    print(f"模块{module_name}有属性{attr_name}")

# 方法3: 动态调用函数
func_name = 'sqrt'
if hasattr(module, func_name):
    func = getattr(module, func_name)
    result = func(16)
    print(f"{func_name}(16) = {result}")
```

### 3. 模块缓存机制
```python
import sys

# 查看模块缓存
print("已缓存的模块:")
cached_modules = list(sys.modules.keys())
print(f"缓存模块数量: {len(cached_modules)}")
print(f"部分模块: {cached_modules[:5]}")

# 检查特定模块是否已缓存
module_name = 'json'
if module_name in sys.modules:
    print(f"{module_name}模块已在缓存中")
    cached_module = sys.modules[module_name]
    print(f"缓存的模块对象: {cached_module}")

# 手动从缓存中移除模块（谨慎使用）
# del sys.modules['some_module']
```

## 🔄 动态导入和重载

### 1. importlib高级用法
```python
import importlib
import importlib.util

# 动态导入模块
def dynamic_import(module_name):
    """动态导入模块"""
    try:
        module = importlib.import_module(module_name)
        print(f"成功导入模块: {module_name}")
        return module
    except ImportError as e:
        print(f"导入失败: {e}")
        return None

# 测试动态导入
json_module = dynamic_import('json')
if json_module:
    data = json_module.dumps({'key': 'value'})
    print(f"JSON数据: {data}")

# 从文件路径导入模块
def import_from_path(module_name, file_path):
    """从指定路径导入模块"""
    spec = importlib.util.spec_from_file_location(module_name, file_path)
    if spec and spec.loader:
        module = importlib.util.module_from_spec(spec)
        spec.loader.exec_module(module)
        return module
    return None

# 重新加载模块（开发时有用）
def reload_module(module):
    """重新加载模块"""
    try:
        importlib.reload(module)
        print(f"模块{module.__name__}重新加载成功")
    except Exception as e:
        print(f"重新加载失败: {e}")
```

### 2. 条件导入和兼容性处理
```python
# 版本兼容性导入
import sys

if sys.version_info >= (3, 8):
    from functools import cached_property
else:
    # 为旧版本提供替代实现
    def cached_property(func):
        return property(func)

# 可选依赖处理
def get_available_features():
    """检查可用功能"""
    features = {}
    
    # 检查NumPy
    try:
        import numpy
        features['numpy'] = numpy.__version__
    except ImportError:
        features['numpy'] = None
    
    # 检查Pandas
    try:
        import pandas
        features['pandas'] = pandas.__version__
    except ImportError:
        features['pandas'] = None
    
    return features

# 平台特定导入
import platform

if platform.system() == 'Windows':
    try:
        import winsound
        def beep():
            winsound.Beep(1000, 500)
    except ImportError:
        def beep():
            print("Beep!")
else:
    def beep():
        print("\a")  # ASCII响铃字符
```

## 📦 包的高级特性

### 1. 命名空间包
```python
# 命名空间包允许将包分布在多个目录中
# 不需要__init__.py文件

# 目录结构:
# namespace_package/
#     part1/
#         module1.py
#     part2/
#         module2.py

# 使用时:
# from namespace_package.part1 import module1
# from namespace_package.part2 import module2
```

### 2. 包的元数据管理
```python
# 在__init__.py中定义包的元数据
__version__ = "1.2.3"
__author__ = "开发团队"
__email__ = "team@example.com"
__license__ = "MIT"
__description__ = "一个示例Python包"

# 版本信息类
class Version:
    def __init__(self, version_string):
        self.version_string = version_string
        self.parts = [int(x) for x in version_string.split('.')]
    
    def __str__(self):
        return self.version_string
    
    def __repr__(self):
        return f"Version('{self.version_string}')"
    
    def __eq__(self, other):
        return self.parts == other.parts
    
    def __lt__(self, other):
        return self.parts < other.parts

# 使用版本类
version = Version(__version__)

def get_package_info():
    """获取包的完整信息"""
    return {
        'name': __name__,
        'version': str(version),
        'author': __author__,
        'email': __email__,
        'license': __license__,
        'description': __description__
    }
```

### 3. 插件系统设计
```python
# 基于包的插件系统
import pkgutil
import importlib

class PluginManager:
    """插件管理器"""
    
    def __init__(self, plugin_package):
        self.plugin_package = plugin_package
        self.plugins = {}
    
    def load_plugins(self):
        """加载所有插件"""
        # 遍历插件包中的所有模块
        for importer, modname, ispkg in pkgutil.iter_modules(
            self.plugin_package.__path__, 
            self.plugin_package.__name__ + "."
        ):
            try:
                module = importlib.import_module(modname)
                if hasattr(module, 'register_plugin'):
                    plugin = module.register_plugin()
                    self.plugins[plugin.name] = plugin
                    print(f"加载插件: {plugin.name}")
            except Exception as e:
                print(f"加载插件{modname}失败: {e}")
    
    def get_plugin(self, name):
        """获取指定插件"""
        return self.plugins.get(name)
    
    def list_plugins(self):
        """列出所有插件"""
        return list(self.plugins.keys())

# 插件基类
class Plugin:
    """插件基类"""
    
    def __init__(self, name, version="1.0.0"):
        self.name = name
        self.version = version
    
    def execute(self, *args, **kwargs):
        """执行插件功能"""
        raise NotImplementedError("子类必须实现execute方法")
```

## 🔍 模块搜索和发现

### 1. 自定义模块查找器
```python
import sys
import importlib.util
from pathlib import Path

class CustomFinder:
    """自定义模块查找器"""
    
    def __init__(self, search_paths):
        self.search_paths = [Path(p) for p in search_paths]
    
    def find_spec(self, name, path, target=None):
        """查找模块规范"""
        for search_path in self.search_paths:
            module_file = search_path / f"{name}.py"
            if module_file.exists():
                spec = importlib.util.spec_from_file_location(
                    name, module_file
                )
                return spec
        return None

# 注册自定义查找器
custom_finder = CustomFinder(['/custom/modules/path'])
sys.meta_path.insert(0, custom_finder)
```

### 2. 模块发现工具
```python
import pkgutil
import importlib

def discover_modules(package_name):
    """发现包中的所有模块"""
    try:
        package = importlib.import_module(package_name)
    except ImportError:
        print(f"包{package_name}不存在")
        return []
    
    modules = []
    for importer, modname, ispkg in pkgutil.iter_modules(
        package.__path__, package.__name__ + "."
    ):
        modules.append({
            'name': modname,
            'is_package': ispkg,
            'importer': importer
        })
    
    return modules

# 使用示例
# modules = discover_modules('json')
# for module in modules:
#     print(f"模块: {module['name']}, 是包: {module['is_package']}")
```

## ⚡ 性能优化

### 1. 延迟导入
```python
# 延迟导入减少启动时间
class DataProcessor:
    """数据处理器，使用延迟导入"""
    
    def __init__(self):
        self._pandas = None
        self._numpy = None
    
    @property
    def pandas(self):
        """延迟导入pandas"""
        if self._pandas is None:
            try:
                import pandas as pd
                self._pandas = pd
            except ImportError:
                raise ImportError("需要安装pandas")
        return self._pandas
    
    @property
    def numpy(self):
        """延迟导入numpy"""
        if self._numpy is None:
            try:
                import numpy as np
                self._numpy = np
            except ImportError:
                raise ImportError("需要安装numpy")
        return self._numpy
    
    def process_data(self, data):
        """处理数据"""
        # 只有在实际使用时才导入
        df = self.pandas.DataFrame(data)
        array = self.numpy.array(data)
        return df, array
```

### 2. 模块导入时间分析
```python
import time
import sys

class ImportTimer:
    """导入时间分析器"""
    
    def __init__(self):
        self.import_times = {}
    
    def time_import(self, module_name):
        """测量模块导入时间"""
        # 确保模块不在缓存中
        if module_name in sys.modules:
            del sys.modules[module_name]
        
        start_time = time.perf_counter()
        try:
            __import__(module_name)
            end_time = time.perf_counter()
            import_time = end_time - start_time
            self.import_times[module_name] = import_time
            return import_time
        except ImportError as e:
            print(f"导入{module_name}失败: {e}")
            return None
    
    def analyze_imports(self, module_names):
        """分析多个模块的导入时间"""
        results = {}
        for module_name in module_names:
            import_time = self.time_import(module_name)
            if import_time is not None:
                results[module_name] = import_time
        
        # 按导入时间排序
        sorted_results = sorted(results.items(), key=lambda x: x[1], reverse=True)
        
        print("模块导入时间分析:")
        for module_name, import_time in sorted_results:
            print(f"{module_name}: {import_time:.4f}秒")
        
        return results

# 使用示例
# timer = ImportTimer()
# modules_to_test = ['json', 'os', 'sys', 'datetime', 'math']
# timer.analyze_imports(modules_to_test)
```

## 🛡️ 安全考虑

### 1. 安全的动态导入
```python
import importlib
import sys

def safe_import(module_name, allowed_modules=None):
    """安全的动态导入"""
    # 检查允许列表
    if allowed_modules and module_name not in allowed_modules:
        raise ImportError(f"模块{module_name}不在允许列表中")
    
    # 检查模块名的合法性
    if not module_name.replace('.', '').replace('_', '').isalnum():
        raise ImportError(f"模块名{module_name}包含非法字符")
    
    # 限制导入深度
    if module_name.count('.') > 5:
        raise ImportError(f"模块{module_name}嵌套层次过深")
    
    try:
        return importlib.import_module(module_name)
    except ImportError as e:
        print(f"安全导入失败: {e}")
        return None

# 使用示例
allowed = ['json', 'os', 'sys', 'math']
module = safe_import('json', allowed)
```

### 2. 模块完整性检查
```python
import hashlib
import importlib.util

def verify_module_integrity(module_path, expected_hash):
    """验证模块文件完整性"""
    try:
        with open(module_path, 'rb') as f:
            content = f.read()
            actual_hash = hashlib.sha256(content).hexdigest()
            return actual_hash == expected_hash
    except Exception:
        return False

def secure_import_from_path(module_name, file_path, expected_hash=None):
    """安全地从路径导入模块"""
    # 验证文件完整性
    if expected_hash and not verify_module_integrity(file_path, expected_hash):
        raise ImportError("模块文件完整性验证失败")
    
    # 导入模块
    spec = importlib.util.spec_from_file_location(module_name, file_path)
    if spec and spec.loader:
        module = importlib.util.module_from_spec(spec)
        spec.loader.exec_module(module)
        return module
    
    raise ImportError(f"无法从{file_path}导入模块{module_name}")
```

## 🎯 本节小结

- **模块内省**：使用dir()、getattr()、hasattr()等函数检查模块属性
- **动态导入**：使用importlib进行运行时模块导入和重载
- **包的高级特性**：命名空间包、元数据管理、插件系统
- **性能优化**：延迟导入、导入时间分析
- **安全考虑**：安全的动态导入、模块完整性检查

## 💡 实践建议

1. **谨慎使用动态导入**：只在确实需要时使用，注意安全性
2. **合理使用延迟导入**：对于大型库或可选依赖使用延迟导入
3. **模块缓存机制**：理解Python的模块缓存，避免重复导入
4. **插件系统设计**：使用包的特性设计灵活的插件系统

## 📚 下一步学习
学习完高级特性后，接下来学习 **[07-最佳实践.md](./07-最佳实践.md)**，了解模块和包的开发规范。
