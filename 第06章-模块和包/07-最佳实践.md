# 07-最佳实践

## 📋 模块设计原则

### 1. 单一职责原则
每个模块应该只负责一个特定的功能领域：

```python
# ✅ 好的做法 - 职责明确
# math_utils.py - 只包含数学相关功能
def add(a, b):
    return a + b

def multiply(a, b):
    return a * b

def calculate_area(radius):
    return 3.14159 * radius ** 2

# string_utils.py - 只包含字符串处理功能
def reverse_string(s):
    return s[::-1]

def capitalize_words(s):
    return s.title()

# ❌ 不好的做法 - 职责混乱
# utils.py - 包含各种不相关的功能
def add(a, b):           # 数学功能
    return a + b

def reverse_string(s):   # 字符串功能
    return s[::-1]

def read_file(path):     # 文件功能
    with open(path) as f:
        return f.read()
```

### 2. 接口设计原则
模块应该提供清晰、简单、一致的接口：

```python
# ✅ 好的接口设计
def calculate_circle_area(radius):
    """计算圆的面积"""
    if radius < 0:
        raise ValueError("半径不能为负数")
    return 3.14159 * radius ** 2

def calculate_rectangle_area(width, height):
    """计算矩形面积"""
    if width < 0 or height < 0:
        raise ValueError("宽度和高度不能为负数")
    return width * height

# ❌ 不好的接口设计
def calc(r=None, w=None, h=None, shape="circle"):
    """计算面积，shape可以是'circle'或'rectangle'"""
    if shape == "circle" and r is not None:
        return 3.14159 * r ** 2
    elif shape == "rectangle" and w is not None and h is not None:
        return w * h
    else:
        raise ValueError("参数错误")
```

### 3. 最小依赖原则
模块应该尽量减少对其他模块的依赖：

```python
# ✅ 好的做法 - 最小依赖
from math import pi, sqrt  # 只导入需要的函数

def circle_area(radius):
    return pi * radius ** 2

def distance(x1, y1, x2, y2):
    return sqrt((x2 - x1)**2 + (y2 - y1)**2)

# ❌ 不好的做法 - 过度依赖
import math
import os
import sys
import json
import requests  # 实际上只用了math模块

def circle_area(radius):
    return math.pi * radius ** 2
```

## 📝 命名规范

### 1. 模块命名
```python
# ✅ 好的模块名
user_manager.py      # 小写，下划线分隔
data_processor.py    # 描述性强
http_client.py       # 清晰明了

# ❌ 不好的模块名
UserManager.py       # 不要用大写
data-processor.py    # 不要用连字符
utils.py            # 太泛泛，不够具体
temp.py             # 临时性名称
```

### 2. 包命名
```python
# ✅ 好的包名
web_framework/       # 小写，描述性强
data_analysis/       # 功能明确
user_auth/          # 简洁清晰

# ❌ 不好的包名
WebFramework/       # 不要用大写
web-framework/      # 不要用连字符
stuff/             # 太模糊
```

### 3. 函数和变量命名
```python
# ✅ 好的命名
def calculate_total_price(items):
    """计算总价格"""
    total = 0
    for item in items:
        total += item.price
    return total

# 常量使用全大写
MAX_RETRY_COUNT = 3
DEFAULT_TIMEOUT = 30

# 私有函数使用下划线前缀
def _internal_helper():
    """内部辅助函数"""
    pass

# ❌ 不好的命名
def calc(x):         # 名称太短，不清楚
    pass

def getUserData():   # 应该用下划线而不是驼峰
    pass

maxretrycount = 3    # 常量应该全大写
```

## 📚 文档规范

### 1. 模块级文档
```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
user_manager.py - 用户管理模块

这个模块提供用户管理的核心功能，包括：
- 用户注册和登录
- 用户信息管理
- 权限验证

主要类:
    User: 用户数据模型
    UserManager: 用户管理器

主要函数:
    create_user: 创建新用户
    authenticate: 用户认证
    get_user_by_id: 根据ID获取用户

使用示例:
    from user_manager import UserManager
    
    manager = UserManager()
    user = manager.create_user("alice", "password123")
    if manager.authenticate("alice", "password123"):
        print("登录成功")

作者: 开发团队
版本: 1.2.0
创建日期: 2024-01-01
最后修改: 2024-01-15
"""
```

### 2. 函数文档规范
```python
def calculate_compound_interest(principal, rate, time, compound_frequency=1):
    """
    计算复利
    
    使用复利公式计算投资的最终价值：
    A = P(1 + r/n)^(nt)
    
    Args:
        principal (float): 本金，必须为正数
        rate (float): 年利率，以小数形式表示（如0.05表示5%）
        time (float): 投资时间，以年为单位
        compound_frequency (int, optional): 每年复利次数，默认为1
    
    Returns:
        float: 复利计算后的最终金额
    
    Raises:
        ValueError: 当参数为负数或无效时
        TypeError: 当参数类型不正确时
    
    Examples:
        >>> calculate_compound_interest(1000, 0.05, 2)
        1102.5
        >>> calculate_compound_interest(1000, 0.05, 2, 4)
        1104.49
    
    Note:
        计算结果会四舍五入到小数点后2位
    
    See Also:
        calculate_simple_interest: 计算单利
    """
    if principal <= 0:
        raise ValueError("本金必须为正数")
    if rate < 0:
        raise ValueError("利率不能为负数")
    if time < 0:
        raise ValueError("时间不能为负数")
    if compound_frequency <= 0:
        raise ValueError("复利频率必须为正整数")
    
    amount = principal * (1 + rate / compound_frequency) ** (compound_frequency * time)
    return round(amount, 2)
```

### 3. 类文档规范
```python
class BankAccount:
    """
    银行账户类
    
    用于管理银行账户的基本操作，包括存款、取款、查询余额等功能。
    支持多种货币类型和交易历史记录。
    
    Attributes:
        account_number (str): 账户号码，唯一标识
        owner_name (str): 账户所有者姓名
        balance (Decimal): 当前余额，使用Decimal确保精度
        currency (str): 货币类型，默认为'CNY'
        is_active (bool): 账户是否激活
        transaction_history (list): 交易历史记录
    
    Class Attributes:
        MIN_BALANCE (Decimal): 最小余额限制
        MAX_DAILY_WITHDRAWAL (Decimal): 每日最大取款限额
    
    Examples:
        >>> account = BankAccount("123456789", "张三", 1000.00)
        >>> account.deposit(500.00)
        Decimal('1500.00')
        >>> account.withdraw(200.00)
        Decimal('1300.00')
        >>> print(account.get_balance())
        1300.00
    
    Note:
        所有金额计算使用Decimal类型以避免浮点数精度问题
    """
    
    MIN_BALANCE = Decimal('0.00')
    MAX_DAILY_WITHDRAWAL = Decimal('10000.00')
    
    def __init__(self, account_number, owner_name, initial_balance=0):
        """
        初始化银行账户
        
        Args:
            account_number (str): 账户号码
            owner_name (str): 账户所有者姓名
            initial_balance (float, optional): 初始余额，默认为0
        
        Raises:
            ValueError: 当账户号码或姓名为空时
            TypeError: 当初始余额不是数字时
        """
        # 实现代码...
```

## 🏗️ 代码组织结构

### 1. 标准模块结构
```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""模块文档字符串"""

# 1. 标准库导入
import os
import sys
from datetime import datetime
from pathlib import Path

# 2. 第三方库导入
import requests
import numpy as np

# 3. 本地模块导入
from .utils import helper_function
from ..config import settings

# 4. 模块级常量（全大写）
DEFAULT_TIMEOUT = 30
MAX_RETRIES = 3
API_BASE_URL = "https://api.example.com"

# 5. 模块级变量
_cache = {}
_initialized = False

# 6. 异常类定义
class ModuleError(Exception):
    """模块特定异常"""
    pass

class ValidationError(ModuleError):
    """验证错误"""
    pass

# 7. 私有函数（下划线开头）
def _validate_input(data):
    """验证输入数据"""
    if not data:
        raise ValidationError("数据不能为空")

def _format_response(response):
    """格式化响应数据"""
    return response.json() if response else None

# 8. 公共函数
def process_data(data):
    """处理数据的公共函数"""
    _validate_input(data)
    # 处理逻辑
    return processed_data

# 9. 类定义
class DataProcessor:
    """数据处理器类"""
    
    def __init__(self):
        self._setup()
    
    def _setup(self):
        """私有设置方法"""
        pass
    
    def process(self, data):
        """公共处理方法"""
        return process_data(data)

# 10. 模块初始化函数
def _initialize_module():
    """初始化模块"""
    global _initialized
    if not _initialized:
        # 初始化逻辑
        _initialized = True

# 11. 主程序入口
def main():
    """主函数，用于测试或命令行调用"""
    print("模块测试")
    # 测试代码

# 12. 模块级初始化
_initialize_module()

# 13. 条件执行
if __name__ == "__main__":
    main()
```

### 2. 包结构最佳实践
```
my_package/
├── __init__.py          # 包初始化
├── core/                # 核心功能
│   ├── __init__.py
│   ├── engine.py
│   └── processor.py
├── utils/               # 工具函数
│   ├── __init__.py
│   ├── helpers.py
│   └── validators.py
├── models/              # 数据模型
│   ├── __init__.py
│   ├── user.py
│   └── product.py
├── exceptions.py        # 异常定义
├── constants.py         # 常量定义
├── config.py           # 配置管理
└── version.py          # 版本信息
```

## 🧪 测试和质量保证

### 1. 单元测试结构
```python
# test_user_manager.py
import unittest
from unittest.mock import Mock, patch
from user_manager import UserManager, User

class TestUserManager(unittest.TestCase):
    """用户管理器测试类"""
    
    def setUp(self):
        """测试前的设置"""
        self.manager = UserManager()
        self.test_user_data = {
            'username': 'testuser',
            'email': 'test@example.com',
            'password': 'password123'
        }
    
    def tearDown(self):
        """测试后的清理"""
        # 清理测试数据
        pass
    
    def test_create_user_success(self):
        """测试成功创建用户"""
        user = self.manager.create_user(**self.test_user_data)
        self.assertIsInstance(user, User)
        self.assertEqual(user.username, 'testuser')
    
    def test_create_user_duplicate_username(self):
        """测试创建重复用户名的用户"""
        self.manager.create_user(**self.test_user_data)
        with self.assertRaises(ValueError):
            self.manager.create_user(**self.test_user_data)
    
    @patch('user_manager.database.save')
    def test_create_user_database_error(self, mock_save):
        """测试数据库错误情况"""
        mock_save.side_effect = Exception("数据库错误")
        with self.assertRaises(Exception):
            self.manager.create_user(**self.test_user_data)

if __name__ == '__main__':
    unittest.main()
```

### 2. 文档测试
```python
def fibonacci(n):
    """
    计算斐波那契数列的第n项
    
    >>> fibonacci(0)
    0
    >>> fibonacci(1)
    1
    >>> fibonacci(5)
    5
    >>> fibonacci(10)
    55
    >>> fibonacci(-1)
    Traceback (most recent call last):
        ...
    ValueError: n必须为非负整数
    """
    if n < 0:
        raise ValueError("n必须为非负整数")
    if n <= 1:
        return n
    return fibonacci(n-1) + fibonacci(n-2)

if __name__ == "__main__":
    import doctest
    doctest.testmod(verbose=True)
```

## 🔧 配置和环境管理

### 1. 配置文件管理
```python
# config.py
import os
import json
from pathlib import Path

class Config:
    """配置管理类"""
    
    def __init__(self, config_file=None):
        self.config_file = config_file or self._get_default_config_file()
        self._config = self._load_config()
    
    def _get_default_config_file(self):
        """获取默认配置文件路径"""
        # 按优先级查找配置文件
        possible_paths = [
            Path.cwd() / 'config.json',
            Path.home() / '.myapp' / 'config.json',
            Path(__file__).parent / 'default_config.json'
        ]
        
        for path in possible_paths:
            if path.exists():
                return path
        
        return possible_paths[-1]  # 返回默认路径
    
    def _load_config(self):
        """加载配置"""
        try:
            with open(self.config_file, 'r', encoding='utf-8') as f:
                return json.load(f)
        except FileNotFoundError:
            return self._get_default_config()
        except json.JSONDecodeError as e:
            raise ValueError(f"配置文件格式错误: {e}")
    
    def _get_default_config(self):
        """获取默认配置"""
        return {
            'debug': False,
            'database': {
                'host': 'localhost',
                'port': 5432,
                'name': 'myapp'
            },
            'api': {
                'timeout': 30,
                'max_retries': 3
            }
        }
    
    def get(self, key, default=None):
        """获取配置项"""
        keys = key.split('.')
        value = self._config
        
        for k in keys:
            if isinstance(value, dict) and k in value:
                value = value[k]
            else:
                return default
        
        return value
    
    def set(self, key, value):
        """设置配置项"""
        keys = key.split('.')
        config = self._config
        
        for k in keys[:-1]:
            if k not in config:
                config[k] = {}
            config = config[k]
        
        config[keys[-1]] = value
    
    def save(self):
        """保存配置到文件"""
        self.config_file.parent.mkdir(parents=True, exist_ok=True)
        with open(self.config_file, 'w', encoding='utf-8') as f:
            json.dump(self._config, f, indent=2, ensure_ascii=False)

# 全局配置实例
config = Config()
```

### 2. 环境变量支持
```python
# environment.py
import os
from typing import Optional, Union

def get_env_var(name: str, default: Optional[str] = None, 
                var_type: type = str) -> Union[str, int, float, bool]:
    """
    获取环境变量并转换类型
    
    Args:
        name: 环境变量名
        default: 默认值
        var_type: 目标类型
    
    Returns:
        转换后的环境变量值
    """
    value = os.getenv(name, default)
    
    if value is None:
        return None
    
    if var_type == bool:
        return value.lower() in ('true', '1', 'yes', 'on')
    elif var_type == int:
        return int(value)
    elif var_type == float:
        return float(value)
    else:
        return str(value)

# 应用配置
DEBUG = get_env_var('DEBUG', 'False', bool)
DATABASE_URL = get_env_var('DATABASE_URL', 'sqlite:///app.db')
API_KEY = get_env_var('API_KEY')
MAX_WORKERS = get_env_var('MAX_WORKERS', '4', int)
```

## 🎯 本节小结

- **设计原则**：单一职责、清晰接口、最小依赖
- **命名规范**：模块、包、函数、变量的命名约定
- **文档规范**：完整的模块、函数、类文档
- **代码组织**：标准的模块和包结构
- **测试质量**：单元测试、文档测试
- **配置管理**：配置文件和环境变量管理

## 💡 关键要点

1. **一致性**：在整个项目中保持一致的编码风格和命名规范
2. **可读性**：代码应该易于理解，文档应该清晰完整
3. **可测试性**：设计时考虑测试，编写充分的测试用例
4. **可维护性**：合理的结构设计，便于后续维护和扩展
5. **可配置性**：支持灵活的配置管理

## 📦 包的分发和发布

### 概念简介
当你创建了有用的包后，可能希望与他人分享或在不同项目中重用。Python提供了完整的包分发生态系统：

- **打包**：将你的包制作成可分发的格式（如wheel、tar.gz）
- **发布**：将包上传到包仓库（如PyPI）供他人安装使用
- **安装**：使用pip等工具安装和管理包

### 基本流程预览
```bash
# 1. 准备包结构和配置文件
my_package/
├── setup.py 或 pyproject.toml
├── my_package/
│   ├── __init__.py
│   └── module.py
└── README.md

# 2. 构建包
python -m build

# 3. 发布到PyPI
python -m twine upload dist/*

# 4. 安装使用
pip install my_package
```

### 进阶学习指引
包的分发和发布涉及更多技术细节：
- 配置文件编写（setup.py、pyproject.toml）
- 版本管理和依赖声明
- 构建工具使用（build、setuptools）
- 发布流程和PyPI操作
- 持续集成和自动化发布

这些内容将在**第17章-第三方库介绍**和**第18章-项目实战**中详细讲解。

## 📚 总结
通过遵循这些最佳实践，你可以创建高质量、可维护、可扩展的Python模块和包。这些实践不仅适用于个人项目，也是团队协作和开源项目的基础。掌握了包的创建后，下一步就是学习如何分发和发布你的包，让更多人受益于你的代码。
